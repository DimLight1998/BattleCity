# Java 大作业实验报告

[TOC]

## 实现的功能点

已完成作业要求中的所有基本要求和提高要求，具体情况如下：

- **基本图形界面**：游戏的主界面和原版画风基本一致。所用素材直接从原版游戏中截图获得。

- **事件处理**

  - **键盘按键响应**：可通过键盘来控制坦克的开火、移动以及游戏时进行暂停和继续。
  - **碰撞检测**：已实现坦克、子弹以及地形之间的相互碰撞检测，且坦克在移动时碰撞检测的结果基本正常。

- **网络编程**：整个游戏的网络部分的模型大致如下。

  ```mermaid
  graph LR
  d1[Client 1]
  d2[Server]
  d3[Client 2]

  d1---d2
  d2---d3
  ```

  双人游戏进行时一共有三个程序在运行，具体实现在[网络通信部分](#网络通信部分说明)中说明。
  - **使用 Socket 实现网络通信**：已实现服务器和两个客户端之间使用 Socket 进行通信，达到传输操作、同步状态等目的。
  - **客户端策略同步状态**：已实现两客户端间的状态同步，而且在测试中几乎感受不到状态不同的情况。具体实现在[状态同步策略](#状态同步策略说明)中说明。

- **基本功能**

  - **支持开始、暂停、继续**：已实现该功能。一方暂停时双方都会暂停，同时双方都能取消暂停。继续游戏后，双方能够维持同步状态。
  - **支持统计得分**：已实现该功能。游戏中一共有四种坦克，分数都不相同。能够分别统计双方各自的得分并且一同显示。

- **声音和音效**：游戏正式开始后会播放背景音乐，玩家自己控制的坦克开火时，会听见开火的音效。

- **读写文件**：能够保存所有的玩家的得分情况并且对最高五名予以显示。

此外还实现了其它功能：

- **地图编辑和地图选择**：主程序中可以选择打开地图编辑器，可以从中编辑地图并保存。在服务端和两个客户端都具有这个地图文件的情况下，可以选择这张地图进行游戏。同时游戏本身自带一部分已经设计过的地图。

## 操作说明

### 运行说明

#### 开始一局游戏

1. 运行 jar 文件，在界面中选择 Start as server ，在弹出的窗口中填好端口号和地图名称，随后点击 Start 。在游戏正常结束后，会有另一个窗口弹出，提示结束游戏，并关闭服务器。
2. 运行 jar 文件，在界面中选择 Start as a player ，在弹出的窗口中填好服务器的 IP 地址和端口号。随后点击 Start 。进入后游戏的界面只有司令部和两辆坦克，需要等待另一个玩家加入。
3. 再次运行 jar 文件，在界面中选择 Start as a player ，在弹出的窗口中填好服务器的 IP 地址和端口号。随后点击 Start 。此时双方都已就绪，游戏可以开始。

#### 地图编辑和使用

1. 运行 jar 文件，在界面中选择 Map designer 。会弹出如下界面：

   ![snipaste_20170522_162652](picsrc\snipaste_20170522_162652.png)

2. 在左边选中一种地形，然后在地图上左击相应区域即可进行绘制。

3. 绘制完成后，在文本框处输入地图名称，然后点击 Save map 即可进行保存。

**注意**：

- 地图编辑器中有对称选项，可以将地图右边复制到左边或从左边复制到右边。原来的地形将不会存在。
- 地图编辑器中有全部清除选项，会清除所有已编辑信息。
- 地图街面上用紫色标出了坦克的出生区域，无法在此区域进行地图绘制。
- 生成的地图文件后缀名为 map ，但是在服务器选择地图时只需要选择地图名称即可。地图名称中不要含有文件系统不支持的字符。
- 如果需要使用自定义的地图进行游戏，只需要服务器具有该地图文件。存放在和 jar 同级的目录下即可。

### 游戏操作说明

- `W`：坦克向上移动。
- `A`：坦克向左移动。
- `S`：坦克向下移动。
- `D`：坦克向右移动。
- `Space`：开火。
- `P`：控制游戏暂停或继续。

### 游戏规则说明

- 敌方一共有 20 辆坦克，一共有四种。它们的开火速度、移动速度以及血量都不相同。为了区别当前血量，在敌方坦克满血时显示都为灰色，每次受到攻击它们都会改变颜色。
- 敌方在场上最多同时会有 4 辆坦克，每当一辆坦克被玩家消灭，另一辆坦克就会重生。直到 20 辆坦克都被玩家消灭为止，此时玩家胜利。如果玩家的两辆坦克都被消灭，或者玩家的基地遭到破坏，玩家会失败。

其它的游戏机制说明：

- 子弹的抵消：如果两颗子弹在同一直线上以相反速度相遇，那么它们会相互抵消。
- 对于敌方发射的子弹，可以杀伤玩家，但是不会杀伤敌方。对于玩家发射的子弹，既可以杀伤另一个玩家，也可以杀伤敌方。即玩家存在队友伤害，但是敌方不存在。



## 界面设计说明

**总体思路**：每一个窗口都单独写一个类，这些类都继承自 `JPanel` ，其中某些实现了 `ActionListener` 或其它接口。每个类中都有一个 `JFrame` 对象，用来显示这个窗口。同时，这些类大都有一个 `display` 函数用来显示窗口，一个 `dispose` 函数用来关闭窗口。运行程序的过程中，每次都会显示一个窗口。当需要显示其它窗口时，主程序会将当前的窗口通过 `dispose` 函数关闭，然后使用 `display` 打开其它窗口。从程序开始就一直有一个没有界面的程序在运行，这个程序会负责打开和关闭窗口。

一共实现了以下几个窗口：

- 程序打开时的功能选择界面
- 服务器端的设置界面
- 客户端的设置界面
- 客户端进行游戏时的界面
- 客户端游戏结束时输入姓名的界面
- 地图编辑界面

下面具体讲**客户端游戏界面**和**地图编辑界面**：

### 客户端游戏界面

整个游戏界面是在一个 `JPanel` 上面进行绘制。绘制一共分为 5 层：

1. 最底层，绘制一个黑色的正方形，表示地形的基础（也就是最普通的地形）。
2. 绘制除了草丛之外的所有地形
3. 绘制所有的坦克
4. 绘制所有的子弹
5. 绘制草丛

另外，在这个正方形的右边，实时绘制玩家的分数。这个绘制不是通过标签做到的，而是直接绘制字符串。

这些都被写到了 `paint` 函数中，每次更新（间隔 20 毫秒）时会执行一次这个函数。

### 地图编辑界面

地图编辑界面的主界面由 $30\times30$ 个标签组成，每次点击这些标签就会检查是否需要更新标签的图标，以及更新背后的表示类型的数组。

右边则是一个单选框组和一些按钮，用以进行一些辅助功能。

## 类和模块的设计说明

- common ：存放服务器和客户端共用的一些类。
  - item ：存放游戏的子弹类、坦克类、地形块类。
    - bullet ：存放和子弹相关的类。

      一共有两个类，分别为 `Bullet` 和 `SuperBullet` ，其中 `SuperBullet` 继承自 `Bullet` 。因为计分时需要对两方分别计分，而且敌人没有队友伤害但是玩家有，所以 `SuperBullet` 中记录了该子弹是由哪一个玩家发射的。这个用来标记子弹是由玩家发出的，同时标记是由哪个玩家发出的。

    - tank ：存放和坦克相关的类。

      一共有六个类，其中主要的类是 `Tank` 类。其它五个类都继承自 `Tank` 。五个类中，有一个是玩家的坦克专用的类，剩下四个类代表四种不同的坦克类型。这样在处理的时候可以建立 `Tank` 的 `ArrayList` ，利用多态性可以方便的处理不同属性的多种坦克。具体来讲， `Tank` 是一个抽象类，其中定义了一些抽象函数，例如返回打击这个坦克会得到的分数、这个坦克的发射速率、移动速率等值。而继承自它的几个类则实现了这些函数，如此就可以利用多态性。

    - tile ：存放和地形相关的类。

      一共有十二个类，最基础的 `Tile` 类，这个抽象类定义了其它地形类应该具有的属性。继承自 `Tile` 的各个类都是各种具体的地形，它们具有不同的贴图，也具有不同的属性，例如：

      - 是否是坦克可以穿过的
      - 是否是子弹可以穿过的
      - 是否是子弹可以破坏的
      - 是否是受到攻击后会导致游戏结束的

      同坦克的处理相同，也是利用多态性，让这些具体的地块类返回自己的属性。这样就可以建立 `Tile` 的数组方便地进行处理。
  - logic ：存放服务器和客户端共用的一些处理逻辑的类。
    - AppRunner 类：程序入口的界面设计和逻辑。

      本质上，就是继承了各种功能的带图形界面的程序入口，从这个地方选择希望运行的功能。

    - Emitter 类：用来发送数据的类，在网络通信部分详细说明。

    - InfoHandler 接口：用来处理文本的接口，在网络通信部分详细说明。

    - MapDesigner 类：地图编辑器的界面设计和逻辑。

      逻辑方面，地图信息在游戏内的处理都是用一个整数表示为何种地块。这种表示用于地图的保存以及服务器和客户端传送数据。在进行逻辑处理和绘图时，依然还是利用多态性进行处理。

    - MapLoader 类：用来从地图文件读取地图信息。

      这个类还带有其它的一些功能，例如将地图信息转化成一长串字符串，用来从服务器向客户端发送地图信息。

    - MultipleReceiver 类：用来接受数据，在网络通信部分详细说明。

    - Receiver 类：用来接受数据，在网络通信部分详细说明。
- server ：存放服务器的界面和逻辑需要用到的一些类。
  - gui ：存放服务端的界面设计。
    - Panel_Setup 类：服务端设置界面设计。
  - logic ：存放服务端的逻辑处理类。
    - Server 类：服务端的逻辑处理类。

      这个类是整个程序的核心。这个类中有一个 `start` 函数，调用这个函数后，服务器会处理从分配玩家编号开始一直到显示游戏结束的全部逻辑。同时这个类中有许多用来进行逻辑判断的函数，例如判断碰撞、判断两颗子弹是否会抵消。同时，这个类中有许多指令性的函数，例如向两个客户端发送更新信息。
- client ：存放客户端的界面和逻辑需要用到的一些类。
  - gui ：存放客户端的界面设计。
    - GUI_Play 类：负责游戏进行时整个窗口的显示、音乐等。
    - Panel_Game 类：负责游戏进行时游戏画面的绘制、分数显示等。
    - Panel_Login 类：负责游戏开始前的输入 IP 和端口号等。
    - Panel_Save 类：负责游戏结束后显示历史最高分和输入玩家名称等。
  - logic ：存放客户端的逻辑处理类。
    - Client 类：客户端的逻辑处理类。

      同 `Server` 类一样，这个也处理客户端从尝试连接服务器到保存玩家姓名的所有逻辑。同时这个类中有一些监听事件的函数，用来处理玩家的键盘输入。

    - HistoryItem 类：历史纪录的条项类。

      每个条项由两个数据组成：玩家姓名和其分数。

    - Recorder 类：负责历史记录的读取、排序、保存等。

      这个类负责相关的文件操作和对所有历史纪录的排序等操作。
- res ：存放资源文件，即贴图、音乐和音效。
- OpenClient 类：用来打开一个新的客户端。
- OpenServer 类：用来打开一个新的服务端。

## 网络通信部分说明

**主要思路**：通过服务端和客户端之间利用发送和接收字符串进行通信。

### 相关类和接口的说明

首先是 InfoHandler 接口，这个接口中只有一个函数，表示信息处理。这个函数接受一个字符串和一个 IP 地址，表示接收到了来自这个 IP 的信息。 Server 和 Client 实现了这个接口，这个实现的接口中的函数就是网络通信的处理信息部分。

Emitter 类，构造时接受一个 IP 地址以及一个端口号。然后会建立一个 Socket 用来访问这个 IP 地址的该端口。其中一个主要函数是 `emit(String info)` ，执行这个函数后，一条消息将会发送到指定的 IP 地址上的端口号，这是利用 Socket 的 `writeUTF(String)` 实现的。注意在写完之后，这个 Socket 不会关闭，而是等待下一次消息传输。

Receiver 类，构造时接受一个端口号以及一个 InfoHandler 。然后会在这个端口上建立一个 ServerSocket 。在使用 accept 方法接受到了一个尝试连接的 Socket 之后，就会不断的 readUTF 读取来自该 Socket 的信息，然后将这个信息通过 InfoHandler 进行处理，然后接受下一条信息。这个过程中，接受到的 Socket 不会关闭。而是一直保持连接。

可以见到，一对 Emitter 和 Receiver 即可以做到单向地发送消息并进行处理。在程序中一共使用了四对这样的 Emitter 和 Receiver ，这样即可以实现服务端和客户端的双向通信，而且不需要不停地申请 Socket ，整个过程中程序占用的 Socket 是固定的。

最后是 MultupleReceiver 类，它和 Receiver 类类似，但是不同在与它会在接受一个消息之后，会关闭 Socket 然后重新使用 accept 方法取出一个 Socket 进行接受。

### 流程说明

1. 服务端在服务器上用户指定的端口处建立一个 MultipleReceiver 。假设这个端口号是 6666 。

2. 两个客户端在填写完相关信息后，根据信息建立了两个 Emitter 。同时，也建立了两个 Receiver ，这个端口号是系统分配的而不是指定的。

3. 两个客户端会先后向服务端发送以下内容：自己的 IP 地址以及自己的 Receiver 所在的端口号。

4. 服务端在 MultipleReceiver 接收到消息之后就能够确定两个客户端发送信息的先后，还能够确定客户端的 IP 地址以及 Receiver 所在的端口号。

5. 服务端在 MultipleReceiver 接收到两个消息之后，会关闭 MultipleReceiver ，此时 6666 端口号被释放。（**也就是说，在开启服务器时使用的端口号的真实寿命很短，游戏的大部分过程中都没有用到这个端口**）同时，客户端的 Emitter 会暂时失效。

6. 服务端新建两个 Emitter ，端口号由系统分配。

7. 服务端根据客户端传过来的 IP 地址和 Receiver 端口号，正确设置好自己的两个 Emitter ，随后，向客户端发送以下内容：这个客户端的编号以及与这个客户端对应的服务端的 Receiver 的端口号。

8. 客户端的 Receiver 在接收到上述信息后，更新自己的 Emitter 的属性。

9. 此时，四对 Emitter 和 Receiver 全部设置完毕。接下来是这样的一个循环：
   1. 服务端（或客户端）在需要的时候，利用 Emitter 发送一条消息；

   2. 客户端（或服务端）的 Receiver 在接收到消息后，利用 InfoHandler 将消息传给客户端（或服务端）进行处理。

      例如，服务器在判定了游戏结束后，通过 `emit("gameover")` 来向客户端发送信息，客户端收到后会执行 `handleInfo("gameover")` ，然后在这个函数中会进行相关的处理操作。

10. 最后，当服务器发送了表示游戏结束的消息时，服务端关闭自己的 Socket ，客户端接受后，也关闭自己的 Socket 。

*注：在测试中有极小频率会出现和网络相关的 bug ，这个 bug 会导致服务端不断向客户端发送信息但是没有将信息分开，客户端会不断接收信息也没办法断开。此时客户端将会无视碰撞进行绘制。这个时候只能重新开始游戏。*

## 状态同步策略说明

**主要思路**：为了保证同步，需要两客户端在长时间内能够显示一样的内容。为了保证流畅，客户端应该自己能够处理绘图并且在两次数据同步之间能够推断性地绘图。程序中，所有的和游戏的逻辑判断都在服务器上面进行，客户端只负责收集按键信息和绘图。

- 服务端存放着所有的子弹信息，所有的敌方坦克信息，以及两个玩家的信息，用以进行逻辑判断。
- 客户端存放着相同的信息，但是只是根据这些信息进行绘图，不进行逻辑判断。每隔 100 毫秒，这些信息就会被强制同步一次。

在游戏开始后，玩家每按下一个键或松开一个键，客户端都会无条件地将此信息发送到服务器。当服务器接收后，会检查玩家尝试的行为是否合法，如果不合法就不会进行任何操作，否则，会向客户端发送一条信息，此时客户端将更新玩家的坦克，将其中的速度属性更新。类似地，玩家开火时，服务器会检查这个开火的行为是否合法，然后才告诉客户端添加一颗子弹到所有子弹的集合中。

- 每隔 20 毫秒，客户端会根据自己存放的信息，更新子弹和坦克的位置，然后进行绘制。这种更新不会考虑到碰撞。
- 每隔 20 毫秒，服务端会根据自己存放的信息更新子弹和坦克的位置，然后进行逻辑判断。如果发现有碰撞之类的事件发生，就向客户端发送信息，让客户端停止更新这个物体的位置并更新这个物体的其他属性。
- 每隔 100 毫秒，服务端会整理自己的所有和客户端重合的对象，将它们用字符串表示出来，然后发送到客户端，进行强制同步。客户端在接收之后会解释这些字符串，然后无条件地将自己的对象更新为服务器上传输过来的对象的信息。

在实际测试的效果中，这样做效果还是比较好的。客户端在进行绘制的时候因为绘制的间隔较短，所以看起来是一个连续的动画；因为绘制依据的信息是服务器不久之前的副本（这个时间不会长于 100 毫秒），所以双方显示的内容基本上没有差别。同时，因为每隔一段时间有一次强制同步，所以两个客户端保存的信息在长时间内都是一致的，不会出现时间长后不同步的情况。